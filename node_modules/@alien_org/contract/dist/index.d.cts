//#region src/utils.d.ts
/**
 * Adds a reqId field to the payload.
 * @schema
 */
type WithReqId<T> = T & {
  /**
   * Request identifier.
   * @schema
   */
  reqId: string;
};
/**
 * Semantic versioning type.
 * @example
 * type Version = '1.0.0';
 */
type Version = `${number}.${number}.${number}`;
/**
 * Extracts keys, that are present in the type if it is an object.
 * @example
 * type Keys = UnionKeys<{ a: string, b: number }>;
 * // Keys = 'a' | 'b'
 */
type UnionKeys<T> = T extends T ? keyof T : never;
/**
 * Checks if a type is never.
 * @example
 * type IsNever = IsNever<never>;
 * // IsNever = true
 */
type IsNever<T> = [T] extends [never] ? true : false;
/**
 * Conditional type.
 * @example
 * type If = If<true, 'true', 'false'>;
 * // If = 'true'
 */
type If<Cond extends boolean, True, False> = Cond extends true ? True : False;
/**
 * Empty object type.
 * @example
 * type Empty = Empty;
 * // Empty = {}
 */
type Empty = Record<string, never>;
/**
 * Client-side payment error codes (pre-broadcast failures).
 * Returned when `status` is `'failed'` in `payment:response`.
 * These errors occur before transaction broadcast, so no webhook is sent.
 * @since 0.1.1
 * @schema
 */
type PaymentErrorCode = 'insufficient_balance' | 'network_error' | 'unknown';
/**
 * Webhook status for payment results (on-chain truth).
 * - `'finalized'`: Transaction confirmed on-chain
 * - `'failed'`: Transaction failed on-chain
 * @since 0.1.2
 * @schema
 */
type PaymentWebhookStatus = 'finalized' | 'failed';
/**
 * Payment test scenarios for simulating different payment outcomes.
 *
 * | Scenario | Client sees | Webhook |
 * |----------|-------------|---------|
 * | `'paid'` | `paid` | `{ status: 'finalized' }` |
 * | `'paid:failed'` | `paid` | `{ status: 'failed' }` |
 * | `'cancelled'` | `cancelled` | none |
 * | `'error:*'` | `failed` | none (pre-broadcast) |
 *
 * @example
 * // Happy path: client paid, tx finalized
 * test: 'paid'
 *
 * // On-chain failure: client paid, tx failed
 * test: 'paid:failed'
 *
 * // User cancelled before confirming
 * test: 'cancelled'
 *
 * // Pre-broadcast error (no tx, no webhook)
 * test: 'error:insufficient_balance'
 *
 * @since 0.1.2
 * @schema
 */
type PaymentTestScenario = 'paid' | 'paid:failed' | 'cancelled' | `error:${PaymentErrorCode}`;
//#endregion
//#region src/events/types/payload.d.ts
/**
 * Creates event payload types.
 */
interface CreateEventPayload<Payload = never> {
  payload: Payload;
}
//#endregion
//#region src/events/definitions/events.d.ts
/**
 * Events interface defining all available events and their payloads.
 * @since 0.0.1
 * @schema
 */
interface Events {
  /**
   * Miniapp close event, fired by the host app just before the miniapp is closed.
   * @since 0.0.14
   * @schema
   */
  'miniapp:close': CreateEventPayload<Empty>;
  /**
   * Host app's back button clicked event.
   * @since 0.0.14
   * @schema
   */
  'host.back.button:clicked': CreateEventPayload<Empty>;
  /**
   * Payment response event.
   *
   * Statuses:
   * - `paid`: Payment successful, `txHash` included
   * - `cancelled`: User manually cancelled/rejected the payment
   * - `failed`: Error occurred (see `errorCode` for details)
   *
   * For instant fulfillment, your backend should fulfill on webhook receipt
   * using the `invoice` from the request.
   *
   * @since 0.1.1
   * @schema
   */
  'payment:response': CreateEventPayload<WithReqId<{
    /**
     * Payment status.
     * - `paid`: Success
     * - `cancelled`: User rejected
     * - `failed`: Sending transaction failed (check `errorCode`)
     * @since 0.1.1
     * @schema
     */
    status: 'paid' | 'cancelled' | 'failed';
    /**
     * Transaction hash (present when status is 'paid').
     * @since 0.1.1
     * @schema
     */
    txHash?: string;
    /**
     * Error code (present when status is 'failed').
     * - `insufficient_balance`: User doesn't have enough tokens
     * - `network_error`: Blockchain network issue
     * - `unknown`: Unexpected error
     * @since 0.1.1
     * @schema
     */
    errorCode?: PaymentErrorCode;
  }>>;
  /**
   * Clipboard read response.
   *
   * On success: `text` contains the clipboard content (may be empty string).
   * On failure: `text` is null and `errorCode` indicates the reason.
   *
   * @since 0.1.1
   * @schema
   */
  'clipboard:response': CreateEventPayload<WithReqId<{
    /**
     * Text from clipboard. Null if read failed.
     * @since 0.1.1
     * @schema
     */
    text: string | null;
    /**
     * Error code if clipboard read failed.
     * - `permission_denied`: User denied clipboard access
     * - `unavailable`: Clipboard is not available
     * @since 0.1.1
     * @schema
     */
    errorCode?: 'permission_denied' | 'unavailable';
  }>>;
}
//#endregion
//#region src/events/types/event-types.d.ts
type EventName = keyof Events;
type EventPayload<E extends EventName> = Events[E]['payload'];
//#endregion
//#region src/launch-params.d.ts
/**
 * Supported platforms for miniapps.
 */
declare const PLATFORMS: readonly ["ios", "android"];
/**
 * Platform the miniapp is running on.
 */
type Platform = (typeof PLATFORMS)[number];
/**
 * Safe area insets in CSS pixels, injected by the host app.
 * Accounts for system UI (status bar, notch, home indicator, nav bar).
 */
interface SafeAreaInsets {
  top: number;
  right: number;
  bottom: number;
  left: number;
}
/**
 * Launch parameters injected by the host app.
 */
interface LaunchParams {
  /** JWT auth token injected by host app */
  authToken: string | undefined;
  /** Contract version supported by host app (semver) */
  contractVersion: Version | undefined;
  /** Host app version (e.g., '1.2.3') */
  hostAppVersion: string | undefined;
  /** Platform the miniapp is running on */
  platform: Platform | undefined;
  /** Safe area insets for the webview in CSS pixels */
  safeAreaInsets: SafeAreaInsets | undefined;
  /**
   * Custom start parameter injected by host app.
   * Used for referral codes, campaign tracking, or custom routing.
   */
  startParam: string | undefined;
}
//#endregion
//#region src/methods/types/payload.d.ts
/**
 * Creates method payload types.
 */
interface CreateMethodPayload<Payload = never, VersionedPayload extends UnionKeys<Payload> = never> {
  payload: Payload;
  versionedPayload: VersionedPayload;
}
//#endregion
//#region src/methods/definitions/methods.d.ts
/**
 * Methods interface defining all available methods and their payloads.
 * @schema
 */
interface Methods {
  /**
   * Miniapp ready method.
   * Sent by the miniapp to notify the host app that it has loaded and is ready to be displayed.
   * @since 0.0.1
   * @schema
   */
  'app:ready': CreateMethodPayload<Empty>;
  /**
   * Miniapp close acknowledgment method.
   * Sent by the miniapp to notify the host app that it has completed cleanup and is ready to be closed.
   * Note that if the miniapp takes longer than 10 seconds to close, the host app will force close the miniapp.
   * @since 0.0.14
   * @schema
   */
  'miniapp:close.ack': CreateMethodPayload<Empty>;
  /**
   * Toggle host app's back button visibility.
   * @since 0.0.14
   * @schema
   */
  'host.back.button:toggle': CreateMethodPayload<{
    /**
     * Whether to show or hide the back button.
     * @since 0.0.14
     * @schema
     */
    visible: boolean;
  }>;
  /**
   * Request a payment from the user.
   *
   * The `invoice` field is your order/invoice ID for backend correlation.
   * Your backend receives a webhook when user pays - fulfill the order
   * immediately without waiting for chain confirmation.
   *
   * Optional display fields (`title`, `caption`, `iconUrl`, `quantity`)
   * are shown on the payment approval screen.
   *
   * Set `test` to a scenario string (e.g. `'paid'`, `'error:insufficient_balance'`)
   * for test mode - no real payment is made, but the specified scenario is
   * simulated. Use for development and testing.
   *
   * @since 0.1.1
   * @schema
   */
  'payment:request': CreateMethodPayload<WithReqId<{
    /**
     * The recipient's wallet address.
     * @since 0.1.1
     * @schema
     */
    recipient: string;
    /**
     * The amount to pay (in token's smallest unit, as string for precision).
     * @since 0.1.1
     * @schema
     */
    amount: string;
    /**
     * The token identifier (e.g., 'SOL', 'ALIEN', or contract address).
     * @since 0.1.1
     * @schema
     */
    token: string;
    /**
     * The network for the payment ('solana' or 'alien').
     * @since 0.1.1
     * @schema
     */
    network: string;
    /**
     * Your order/invoice ID for backend correlation and instant fulfillment.
     * @since 0.1.1
     * @schema
     */
    invoice: string;
    /**
     * Optional item details shown on the approval screen.
     * @since 0.1.1
     * @schema
     */
    item?: {
      /**
       * Item title shown on the approval screen.
       * @since 0.1.1
       * @schema
       */
      title: string;
      /**
       * Item icon URL shown on the approval screen.
       * @since 0.1.1
       * @schema
       */
      iconUrl: string;
      /**
       * Quantity of items being purchased.
       * @since 0.1.1
       * @schema
       */
      quantity: number;
    };
    /**
     * Test mode. Simulates payment outcomes without real transactions.
     *
     * | Scenario | Client | Webhook |
     * |----------|--------|---------|
     * | `'paid'` | `paid` | `finalized` |
     * | `'paid:failed'` | `paid` | `failed` |
     * | `'cancelled'` | `cancelled` | none |
     * | `'error:*'` | `failed` | none |
     *
     * **Pre-broadcast errors** (no webhook):
     * `'error:insufficient_balance'`, `'error:network_error'`,
     * `'error:unknown'`
     *
     * @example
     * // Happy path
     * test: 'paid'
     *
     * // Client shows success, but tx failed on-chain
     * test: 'paid:failed'
     *
     * // User cancelled
     * test: 'cancelled'
     *
     * // Pre-broadcast failure
     * test: 'error:insufficient_balance'
     *
     * @since 0.1.1
     * @schema
     */
    test?: PaymentTestScenario;
  }>>;
  /**
   * Write text to the system clipboard.
   * @since 0.1.1
   * @schema
   */
  'clipboard:write': CreateMethodPayload<{
    /**
     * Text to copy to clipboard.
     * @since 0.1.1
     * @schema
     */
    text: string;
  }>;
  /**
   * Read text from the system clipboard.
   * @since 0.1.1
   * @schema
   */
  'clipboard:read': CreateMethodPayload<WithReqId<Empty>>;
  /**
   * Open a URL.
   *
   * The host app acts as middleware: parses the URL, checks permissions/auth,
   * and routes to the appropriate handler based on URL and `openMode`.
   *
   * **`external`** (default) - Open outside the host app:
   * - Custom schemes (`solana:`, `mailto:`) → system handler
   * - HTTPS → system browser
   *
   * **`internal`** - Open within the host app:
   * - Miniapp links → open miniapp (handles auth if required)
   * - Other links → in-app webview
   *
   * @example
   * emit('link:open', { url: 'solana:...' });
   * emit('link:open', { url: 'mailto:hi@example.com' });
   * emit('link:open', { url: 'https://example.com', openMode: 'internal' });
   *
   * @since 0.1.3
   * @schema
   */
  'link:open': CreateMethodPayload<{
    /**
     * The URL to open.
     * @since 0.1.3
     * @schema
     */
    url: string;
    /**
     * Where to open the URL.
     * - `external` (default): System browser or app handler
     * - `internal`: Within the host app (miniapps, webviews)
     * @since 0.1.3
     * @schema
     */
    openMode?: 'external' | 'internal';
  }>;
}
//#endregion
//#region src/methods/types/method-types.d.ts
type MethodName = keyof Methods;
type MethodPayload<M$1 extends MethodName> = Methods[M$1]['payload'];
/**
 * Method names which have versioned payload.
 */
type MethodNameWithVersionedPayload = { [M in MethodName]: If<IsNever<Methods[M]['versionedPayload']>, never, M> }[MethodName];
/**
 * Method payload which appear only in the specific version.
 */
type MethodVersionedPayload<M$1 extends MethodNameWithVersionedPayload> = Methods[M$1]['versionedPayload'];
//#endregion
//#region src/methods/versions/get-release-version.d.ts
/**
 * @returns Version of the specified method parameter release. Returns `null`
 * if passed method or parameter are unknown.
 * @param method - method name
 * @param param - method parameter
 */
declare function getReleaseVersion<M$1 extends MethodNameWithVersionedPayload>(method: M$1, payload: MethodVersionedPayload<M$1>): Version | null;
declare function getReleaseVersion(method: MethodName): Version | null;
//#endregion
//#region src/methods/versions/releases.d.ts
declare const releases: Record<Version, (MethodName | {
  method: MethodNameWithVersionedPayload;
  param: MethodVersionedPayload<MethodNameWithVersionedPayload>;
})[]>;
//#endregion
//#region src/methods/versions/index.d.ts
/**
 * Check if a method is supported in a given version.
 *
 * Uses the minimum version that introduced the method and returns true if
 * the given version is >= that minimum (semver comparison). This supports
 * versions not explicitly listed in releases (e.g. 0.1.4 when method was
 * added in 0.1.1).
 *
 * @param method - The method name to check.
 * @param version - The contract version (must be a valid version string, not undefined).
 * @returns `true` if the method is supported in the given version, `false` otherwise.
 *
 * @remarks
 * This function only accepts valid version strings. Version existence checks should be
 * handled at a higher level before calling this function.
 */
declare function isMethodSupported(method: MethodName, version: Version): boolean;
/**
 * Get the minimum version that supports a method.
 * Returns undefined if method not found in any version.
 */
declare function getMethodMinVersion(method: MethodName): Version | undefined;
//#endregion
export { type CreateEventPayload, type CreateMethodPayload, type EventName, type EventPayload, type Events, type LaunchParams, type MethodName, type MethodNameWithVersionedPayload, type MethodPayload, type MethodVersionedPayload, type Methods, PLATFORMS, type PaymentErrorCode, type PaymentTestScenario, type PaymentWebhookStatus, type Platform, type SafeAreaInsets, type Version, getMethodMinVersion, getReleaseVersion, isMethodSupported, releases };