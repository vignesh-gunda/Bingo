//#region ../contract/src/utils.d.ts
/**
 * Adds a reqId field to the payload.
 * @schema
 */
type WithReqId<T> = T & {
  /**
   * Request identifier.
   * @schema
   */
  reqId: string;
};
/**
 * Semantic versioning type.
 * @example
 * type Version = '1.0.0';
 */
type Version = `${number}.${number}.${number}`;
/**
 * Extracts keys, that are present in the type if it is an object.
 * @example
 * type Keys = UnionKeys<{ a: string, b: number }>;
 * // Keys = 'a' | 'b'
 */
type UnionKeys<T> = T extends T ? keyof T : never;
/**
 * Empty object type.
 * @example
 * type Empty = Empty;
 * // Empty = {}
 */
type Empty = Record<string, never>;
/**
 * Client-side payment error codes (pre-broadcast failures).
 * Returned when `status` is `'failed'` in `payment:response`.
 * These errors occur before transaction broadcast, so no webhook is sent.
 * @since 0.1.1
 * @schema
 */
type PaymentErrorCode = 'insufficient_balance' | 'network_error' | 'unknown';
/**
 * Payment test scenarios for simulating different payment outcomes.
 *
 * | Scenario | Client sees | Webhook |
 * |----------|-------------|---------|
 * | `'paid'` | `paid` | `{ status: 'finalized' }` |
 * | `'paid:failed'` | `paid` | `{ status: 'failed' }` |
 * | `'cancelled'` | `cancelled` | none |
 * | `'error:*'` | `failed` | none (pre-broadcast) |
 *
 * @example
 * // Happy path: client paid, tx finalized
 * test: 'paid'
 *
 * // On-chain failure: client paid, tx failed
 * test: 'paid:failed'
 *
 * // User cancelled before confirming
 * test: 'cancelled'
 *
 * // Pre-broadcast error (no tx, no webhook)
 * test: 'error:insufficient_balance'
 *
 * @since 0.1.2
 * @schema
 */
type PaymentTestScenario = 'paid' | 'paid:failed' | 'cancelled' | `error:${PaymentErrorCode}`;
//#endregion
//#region ../contract/src/events/types/payload.d.ts
/**
 * Creates event payload types.
 */
interface CreateEventPayload<Payload = never> {
  payload: Payload;
}
//#endregion
//#region ../contract/src/events/definitions/events.d.ts
/**
 * Events interface defining all available events and their payloads.
 * @since 0.0.1
 * @schema
 */
interface Events {
  /**
   * Miniapp close event, fired by the host app just before the miniapp is closed.
   * @since 0.0.14
   * @schema
   */
  'miniapp:close': CreateEventPayload<Empty>;
  /**
   * Host app's back button clicked event.
   * @since 0.0.14
   * @schema
   */
  'host.back.button:clicked': CreateEventPayload<Empty>;
  /**
   * Payment response event.
   *
   * Statuses:
   * - `paid`: Payment successful, `txHash` included
   * - `cancelled`: User manually cancelled/rejected the payment
   * - `failed`: Error occurred (see `errorCode` for details)
   *
   * For instant fulfillment, your backend should fulfill on webhook receipt
   * using the `invoice` from the request.
   *
   * @since 0.1.1
   * @schema
   */
  'payment:response': CreateEventPayload<WithReqId<{
    /**
     * Payment status.
     * - `paid`: Success
     * - `cancelled`: User rejected
     * - `failed`: Sending transaction failed (check `errorCode`)
     * @since 0.1.1
     * @schema
     */
    status: 'paid' | 'cancelled' | 'failed';
    /**
     * Transaction hash (present when status is 'paid').
     * @since 0.1.1
     * @schema
     */
    txHash?: string;
    /**
     * Error code (present when status is 'failed').
     * - `insufficient_balance`: User doesn't have enough tokens
     * - `network_error`: Blockchain network issue
     * - `unknown`: Unexpected error
     * @since 0.1.1
     * @schema
     */
    errorCode?: PaymentErrorCode;
  }>>;
  /**
   * Clipboard read response.
   *
   * On success: `text` contains the clipboard content (may be empty string).
   * On failure: `text` is null and `errorCode` indicates the reason.
   *
   * @since 0.1.1
   * @schema
   */
  'clipboard:response': CreateEventPayload<WithReqId<{
    /**
     * Text from clipboard. Null if read failed.
     * @since 0.1.1
     * @schema
     */
    text: string | null;
    /**
     * Error code if clipboard read failed.
     * - `permission_denied`: User denied clipboard access
     * - `unavailable`: Clipboard is not available
     * @since 0.1.1
     * @schema
     */
    errorCode?: 'permission_denied' | 'unavailable';
  }>>;
}
//#endregion
//#region ../contract/src/events/types/event-types.d.ts
type EventName = keyof Events;
type EventPayload<E extends EventName> = Events[E]['payload'];
//#endregion
//#region ../contract/src/launch-params.d.ts
/**
 * Supported platforms for miniapps.
 */
declare const PLATFORMS: readonly ["ios", "android"];
/**
 * Platform the miniapp is running on.
 */
type Platform = (typeof PLATFORMS)[number];
/**
 * Safe area insets in CSS pixels, injected by the host app.
 * Accounts for system UI (status bar, notch, home indicator, nav bar).
 */
interface SafeAreaInsets {
  top: number;
  right: number;
  bottom: number;
  left: number;
}
/**
 * Launch parameters injected by the host app.
 */
interface LaunchParams {
  /** JWT auth token injected by host app */
  authToken: string | undefined;
  /** Contract version supported by host app (semver) */
  contractVersion: Version | undefined;
  /** Host app version (e.g., '1.2.3') */
  hostAppVersion: string | undefined;
  /** Platform the miniapp is running on */
  platform: Platform | undefined;
  /** Safe area insets for the webview in CSS pixels */
  safeAreaInsets: SafeAreaInsets | undefined;
  /**
   * Custom start parameter injected by host app.
   * Used for referral codes, campaign tracking, or custom routing.
   */
  startParam: string | undefined;
}
//#endregion
//#region ../contract/src/methods/types/payload.d.ts
/**
 * Creates method payload types.
 */
interface CreateMethodPayload<Payload = never, VersionedPayload extends UnionKeys<Payload> = never> {
  payload: Payload;
  versionedPayload: VersionedPayload;
}
//#endregion
//#region ../contract/src/methods/definitions/methods.d.ts
/**
 * Methods interface defining all available methods and their payloads.
 * @schema
 */
interface Methods {
  /**
   * Miniapp ready method.
   * Sent by the miniapp to notify the host app that it has loaded and is ready to be displayed.
   * @since 0.0.1
   * @schema
   */
  'app:ready': CreateMethodPayload<Empty>;
  /**
   * Miniapp close acknowledgment method.
   * Sent by the miniapp to notify the host app that it has completed cleanup and is ready to be closed.
   * Note that if the miniapp takes longer than 10 seconds to close, the host app will force close the miniapp.
   * @since 0.0.14
   * @schema
   */
  'miniapp:close.ack': CreateMethodPayload<Empty>;
  /**
   * Toggle host app's back button visibility.
   * @since 0.0.14
   * @schema
   */
  'host.back.button:toggle': CreateMethodPayload<{
    /**
     * Whether to show or hide the back button.
     * @since 0.0.14
     * @schema
     */
    visible: boolean;
  }>;
  /**
   * Request a payment from the user.
   *
   * The `invoice` field is your order/invoice ID for backend correlation.
   * Your backend receives a webhook when user pays - fulfill the order
   * immediately without waiting for chain confirmation.
   *
   * Optional display fields (`title`, `caption`, `iconUrl`, `quantity`)
   * are shown on the payment approval screen.
   *
   * Set `test` to a scenario string (e.g. `'paid'`, `'error:insufficient_balance'`)
   * for test mode - no real payment is made, but the specified scenario is
   * simulated. Use for development and testing.
   *
   * @since 0.1.1
   * @schema
   */
  'payment:request': CreateMethodPayload<WithReqId<{
    /**
     * The recipient's wallet address.
     * @since 0.1.1
     * @schema
     */
    recipient: string;
    /**
     * The amount to pay (in token's smallest unit, as string for precision).
     * @since 0.1.1
     * @schema
     */
    amount: string;
    /**
     * The token identifier (e.g., 'SOL', 'ALIEN', or contract address).
     * @since 0.1.1
     * @schema
     */
    token: string;
    /**
     * The network for the payment ('solana' or 'alien').
     * @since 0.1.1
     * @schema
     */
    network: string;
    /**
     * Your order/invoice ID for backend correlation and instant fulfillment.
     * @since 0.1.1
     * @schema
     */
    invoice: string;
    /**
     * Optional item details shown on the approval screen.
     * @since 0.1.1
     * @schema
     */
    item?: {
      /**
       * Item title shown on the approval screen.
       * @since 0.1.1
       * @schema
       */
      title: string;
      /**
       * Item icon URL shown on the approval screen.
       * @since 0.1.1
       * @schema
       */
      iconUrl: string;
      /**
       * Quantity of items being purchased.
       * @since 0.1.1
       * @schema
       */
      quantity: number;
    };
    /**
     * Test mode. Simulates payment outcomes without real transactions.
     *
     * | Scenario | Client | Webhook |
     * |----------|--------|---------|
     * | `'paid'` | `paid` | `finalized` |
     * | `'paid:failed'` | `paid` | `failed` |
     * | `'cancelled'` | `cancelled` | none |
     * | `'error:*'` | `failed` | none |
     *
     * **Pre-broadcast errors** (no webhook):
     * `'error:insufficient_balance'`, `'error:network_error'`,
     * `'error:unknown'`
     *
     * @example
     * // Happy path
     * test: 'paid'
     *
     * // Client shows success, but tx failed on-chain
     * test: 'paid:failed'
     *
     * // User cancelled
     * test: 'cancelled'
     *
     * // Pre-broadcast failure
     * test: 'error:insufficient_balance'
     *
     * @since 0.1.1
     * @schema
     */
    test?: PaymentTestScenario;
  }>>;
  /**
   * Write text to the system clipboard.
   * @since 0.1.1
   * @schema
   */
  'clipboard:write': CreateMethodPayload<{
    /**
     * Text to copy to clipboard.
     * @since 0.1.1
     * @schema
     */
    text: string;
  }>;
  /**
   * Read text from the system clipboard.
   * @since 0.1.1
   * @schema
   */
  'clipboard:read': CreateMethodPayload<WithReqId<Empty>>;
  /**
   * Open a URL.
   *
   * The host app acts as middleware: parses the URL, checks permissions/auth,
   * and routes to the appropriate handler based on URL and `openMode`.
   *
   * **`external`** (default) - Open outside the host app:
   * - Custom schemes (`solana:`, `mailto:`) → system handler
   * - HTTPS → system browser
   *
   * **`internal`** - Open within the host app:
   * - Miniapp links → open miniapp (handles auth if required)
   * - Other links → in-app webview
   *
   * @example
   * emit('link:open', { url: 'solana:...' });
   * emit('link:open', { url: 'mailto:hi@example.com' });
   * emit('link:open', { url: 'https://example.com', openMode: 'internal' });
   *
   * @since 0.1.3
   * @schema
   */
  'link:open': CreateMethodPayload<{
    /**
     * The URL to open.
     * @since 0.1.3
     * @schema
     */
    url: string;
    /**
     * Where to open the URL.
     * - `external` (default): System browser or app handler
     * - `internal`: Within the host app (miniapps, webviews)
     * @since 0.1.3
     * @schema
     */
    openMode?: 'external' | 'internal';
  }>;
}
//#endregion
//#region ../contract/src/methods/types/method-types.d.ts
type MethodName = keyof Methods;
type MethodPayload<M$1 extends MethodName> = Methods[M$1]['payload'];
//#endregion
//#region src/errors.d.ts
/**
 * Base class for all bridge-related errors.
 * Allows catching all bridge errors with a single catch block.
 */
declare class BridgeError extends Error {
  constructor(message: string);
}
/**
 * Thrown when the bridge interface is not available.
 * This occurs when the miniapp is not running in Alien App.
 */
declare class BridgeUnavailableError extends BridgeError {
  constructor();
}
/**
 * Thrown when window is undefined (e.g., SSR scenarios).
 */
declare class BridgeWindowUnavailableError extends BridgeError {
  constructor();
}
/**
 * Thrown when a request times out.
 */
declare class BridgeTimeoutError extends BridgeError {
  readonly method: string;
  readonly timeout: number;
  constructor(method: string, timeout: number);
}
//#endregion
//#region src/events.d.ts
type EventListener<T extends EventName = EventName> = (payload: EventPayload<T>) => void;
type EmitteryEventMap = { [K in keyof Events]: Events[K]['payload'] };
declare function on<T extends EventName>(name: T, listener: EventListener<T>): () => void;
declare function off<T extends EventName>(name: T, listener: EventListener<T>): void;
declare function emit<T extends EventName>(name: T, payload: EmitteryEventMap[T]): Promise<void>;
//#endregion
//#region src/launch-params.d.ts
declare global {
  interface Window {
    __ALIEN_AUTH_TOKEN__?: string;
    __ALIEN_CONTRACT_VERSION__?: string;
    __ALIEN_HOST_VERSION__?: string;
    __ALIEN_PLATFORM__?: string;
    __ALIEN_SAFE_AREA_INSETS__?: SafeAreaInsets;
    __ALIEN_START_PARAM__?: string;
  }
}
/**
 * Error thrown when launch params cannot be retrieved.
 */
declare class LaunchParamsError extends Error {
  constructor(message: string);
}
/**
 * Parse launch params from JSON string.
 */
declare function parseLaunchParams(raw: string): LaunchParams;
/**
 * Inject mock launch params for development/testing.
 * Injects directly into window globals (same as host app would).
 * WARNING: Only use in development environments.
 */
declare function mockLaunchParamsForDev(params: Partial<LaunchParams>): void;
/**
 * Clear mock launch params from window globals and sessionStorage.
 */
declare function clearMockLaunchParams(): void;
/**
 * Retrieve launch params from available sources.
 * @throws LaunchParamsError if no source available
 */
declare function retrieveLaunchParams(): LaunchParams;
/**
 * Try to get launch params, returns undefined if unavailable.
 */
declare function getLaunchParams(): LaunchParams | undefined;
//#endregion
//#region src/link-interceptor.d.ts
interface LinkInterceptorOptions {
  /**
   * Where to open intercepted links.
   * - `external` (default): System browser or app handler
   * - `internal`: Within the host app
   * @default 'external'
   */
  openMode?: 'external' | 'internal';
}
/**
 * Intercepts clicks on external links and routes them through `link:open`.
 *
 * Same-origin links pass through for normal in-app navigation.
 * Skips: modifier keys, non-left-click, download links, `javascript:`/`blob:` protocols.
 *
 * @returns Cleanup function to remove the interceptor.
 *
 * @example
 * ```ts
 * const disable = enableLinkInterceptor();
 * // Later: disable();
 * ```
 */
declare function enableLinkInterceptor(options?: LinkInterceptorOptions): () => void;
//#endregion
//#region src/request.d.ts
interface RequestOptions {
  reqId?: string;
  timeout?: number;
}
declare function request<M$1 extends MethodName, E extends EventName>(method: M$1, params: Omit<MethodPayload<M$1>, 'reqId'>, responseEvent: E, options?: RequestOptions): Promise<EventPayload<E>>;
//#endregion
//#region src/send.d.ts
/**
 * Sends a one-way method to the host app without waiting for a response.
 * Use this for fire-and-forget methods like 'app:ready'.
 *
 * @param method - The method name to send
 * @param payload - The method payload
 *
 * @example
 * ```ts
 * import { send } from '@alien_org/bridge';
 *
 * send('app:ready', {});
 * ```
 */
declare function send<M$1 extends MethodName>(method: M$1, payload: MethodPayload<M$1>): void;
//#endregion
//#region src/transport.d.ts
interface MiniAppsBridge {
  postMessage(data: string): void;
}
declare global {
  interface Window {
    __miniAppsBridge__?: MiniAppsBridge;
  }
}
type EventMessage<E extends EventName = EventName> = {
  type: 'event';
  name: E;
  payload: EventPayload<E>;
};
type MethodMessage<M$1 extends MethodName = MethodName> = {
  type: 'method';
  name: M$1;
  payload: MethodPayload<M$1>;
};
type Message = EventMessage | MethodMessage;
//#endregion
//#region src/utils.d.ts
/**
 * Checks if the bridge is available.
 * Utility function for checking bridge availability.
 * @returns `true` if bridge is available, `false` otherwise.
 */
declare function isBridgeAvailable(): boolean;
//#endregion
export { BridgeError, BridgeTimeoutError, BridgeUnavailableError, BridgeWindowUnavailableError, type EventListener, type EventMessage, type EventName, type EventPayload, LaunchParamsError, type LinkInterceptorOptions, type Message, type MethodMessage, type MethodName, type MethodPayload, type RequestOptions, clearMockLaunchParams, emit, enableLinkInterceptor, getLaunchParams, isBridgeAvailable, mockLaunchParamsForDev, off, on, parseLaunchParams, request, retrieveLaunchParams, send };