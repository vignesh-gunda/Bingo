//#region rolldown:runtime
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") {
		for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
			key = keys[i];
			if (!__hasOwnProp.call(to, key) && key !== except) {
				__defProp(to, key, {
					get: ((k) => from[k]).bind(null, key),
					enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
				});
			}
		}
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));

//#endregion
let emittery = require("emittery");
emittery = __toESM(emittery);
let _alien_org_contract = require("@alien_org/contract");

//#region src/errors.ts
/**
* Base class for all bridge-related errors.
* Allows catching all bridge errors with a single catch block.
*/
var BridgeError = class BridgeError extends Error {
	constructor(message) {
		super(message);
		this.name = "BridgeError";
		if (Error.captureStackTrace) Error.captureStackTrace(this, BridgeError);
	}
};
/**
* Thrown when the bridge interface is not available.
* This occurs when the miniapp is not running in Alien App.
*/
var BridgeUnavailableError = class extends BridgeError {
	constructor() {
		super("Bridge is not available. This SDK requires Alien App environment.");
		this.name = "BridgeUnavailableError";
	}
};
/**
* Thrown when window is undefined (e.g., SSR scenarios).
*/
var BridgeWindowUnavailableError = class extends BridgeError {
	constructor() {
		super("Window is not available. This SDK requires a browser environment.");
		this.name = "BridgeWindowUnavailableError";
	}
};
/**
* Thrown when a request times out.
*/
var BridgeTimeoutError = class extends BridgeError {
	method;
	timeout;
	constructor(method, timeout) {
		super(`Request timeout: ${method} (${timeout}ms)`);
		this.name = "BridgeTimeoutError";
		this.method = method;
		this.timeout = timeout;
	}
};

//#endregion
//#region src/transport.ts
/**
* Gets the bridge instance if available.
* Core function used internally by the bridge package.
* @returns The bridge instance, or `undefined` if not available.
*/
function getBridge() {
	if (typeof window === "undefined") return;
	const bridge = window.__miniAppsBridge__;
	if (!bridge || typeof bridge.postMessage !== "function") return;
	return bridge;
}
/**
* Sends a message using the native bridge.
* Throws errors if bridge is unavailable (strict behavior).
*/
function sendMessage(message) {
	const bridge = getBridge();
	if (!bridge) throw new BridgeUnavailableError();
	bridge.postMessage(JSON.stringify(message));
}
/**
* Type guard to validate if data is a valid Message.
*/
function isMessage(data) {
	return data !== null && typeof data === "object" && "type" in data && "name" in data && "payload" in data && (data.type === "event" || data.type === "method");
}
/**
* Sets up a message listener that handles both stringified and object messages.
* This works for all platforms (web, mobile, desktop).
* Returns a no-op cleanup function if window is not available (e.g., SSR scenarios).
*/
function setupMessageListener(handler) {
	if (typeof window === "undefined") return () => {};
	const messageHandler = (event) => {
		let data = event.data;
		if (typeof data === "string") try {
			data = JSON.parse(data);
		} catch {
			return;
		}
		if (isMessage(data)) handler(data);
	};
	window.addEventListener("message", messageHandler);
	return () => {
		window.removeEventListener("message", messageHandler);
	};
}

//#endregion
//#region src/events.ts
var BridgeEmitter = class extends emittery.default {
	constructor() {
		super();
		setupMessageListener((message) => {
			if (message.type === "event") this.emit(message.name, message.payload);
		});
	}
};
const emitter = new BridgeEmitter();
function on(name, listener) {
	emitter.on(name, listener);
	return () => {
		emitter.off(name, listener);
	};
}
function off(name, listener) {
	emitter.off(name, listener);
}
async function emit(name, payload) {
	await emitter.emit(name, payload);
	sendMessage({
		type: "event",
		name,
		payload
	});
}

//#endregion
//#region src/launch-params.ts
const SESSION_STORAGE_KEY = "alien/launchParams";
/**
* Error thrown when launch params cannot be retrieved.
*/
var LaunchParamsError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "LaunchParamsError";
	}
};
function validateVersion(value) {
	if (!value) return void 0;
	return /^\d+\.\d+\.\d+$/.test(value) ? value : void 0;
}
function validatePlatform(value) {
	if (!value) return void 0;
	return _alien_org_contract.PLATFORMS.includes(value) ? value : void 0;
}
function validateSafeAreaInsets(value) {
	if (!value || typeof value !== "object") return void 0;
	const v = value;
	if (typeof v.top !== "number" || typeof v.right !== "number" || typeof v.bottom !== "number" || typeof v.left !== "number") return void 0;
	return {
		top: v.top,
		right: v.right,
		bottom: v.bottom,
		left: v.left
	};
}
function retrieveFromWindow() {
	if (typeof window === "undefined") return null;
	if (window.__ALIEN_AUTH_TOKEN__ === void 0) return null;
	return {
		authToken: window.__ALIEN_AUTH_TOKEN__,
		contractVersion: validateVersion(window.__ALIEN_CONTRACT_VERSION__),
		hostAppVersion: window.__ALIEN_HOST_VERSION__,
		platform: validatePlatform(window.__ALIEN_PLATFORM__),
		safeAreaInsets: validateSafeAreaInsets(window.__ALIEN_SAFE_AREA_INSETS__),
		startParam: window.__ALIEN_START_PARAM__
	};
}
function retrieveFromSessionStorage() {
	if (typeof window === "undefined") return null;
	try {
		const raw = sessionStorage.getItem(SESSION_STORAGE_KEY);
		if (!raw) return null;
		return parseLaunchParams(raw);
	} catch {
		return null;
	}
}
function persistToSessionStorage(params) {
	try {
		sessionStorage.setItem(SESSION_STORAGE_KEY, JSON.stringify(params));
	} catch {}
}
/**
* Parse launch params from JSON string.
*/
function parseLaunchParams(raw) {
	const parsed = JSON.parse(raw);
	return {
		authToken: parsed.authToken,
		contractVersion: validateVersion(parsed.contractVersion),
		hostAppVersion: parsed.hostAppVersion,
		platform: validatePlatform(parsed.platform),
		safeAreaInsets: validateSafeAreaInsets(parsed.safeAreaInsets),
		startParam: parsed.startParam
	};
}
/**
* Inject mock launch params for development/testing.
* Injects directly into window globals (same as host app would).
* WARNING: Only use in development environments.
*/
function mockLaunchParamsForDev(params) {
	if (typeof window === "undefined") throw new LaunchParamsError("Cannot mock launch params: window is undefined");
	console.warn("[@alien_org/bridge] Using mock launch params - dev mode");
	if (params.authToken !== void 0) window.__ALIEN_AUTH_TOKEN__ = params.authToken;
	if (params.contractVersion !== void 0) window.__ALIEN_CONTRACT_VERSION__ = params.contractVersion;
	if (params.hostAppVersion !== void 0) window.__ALIEN_HOST_VERSION__ = params.hostAppVersion;
	if (params.platform !== void 0) window.__ALIEN_PLATFORM__ = params.platform;
	if (params.safeAreaInsets !== void 0) window.__ALIEN_SAFE_AREA_INSETS__ = params.safeAreaInsets;
	if (params.startParam !== void 0) window.__ALIEN_START_PARAM__ = params.startParam;
}
/**
* Clear mock launch params from window globals and sessionStorage.
*/
function clearMockLaunchParams() {
	if (typeof window !== "undefined") {
		delete window.__ALIEN_AUTH_TOKEN__;
		delete window.__ALIEN_CONTRACT_VERSION__;
		delete window.__ALIEN_HOST_VERSION__;
		delete window.__ALIEN_PLATFORM__;
		delete window.__ALIEN_SAFE_AREA_INSETS__;
		delete window.__ALIEN_START_PARAM__;
		try {
			sessionStorage.removeItem(SESSION_STORAGE_KEY);
		} catch {}
	}
}
/**
* Retrieve launch params from available sources.
* @throws LaunchParamsError if no source available
*/
function retrieveLaunchParams() {
	const fromWindow = retrieveFromWindow();
	if (fromWindow) {
		persistToSessionStorage(fromWindow);
		return fromWindow;
	}
	const fromStorage = retrieveFromSessionStorage();
	if (fromStorage) return fromStorage;
	throw new LaunchParamsError("Launch params not available. Running outside Alien App? Use mockLaunchParamsForDev() for development.");
}
/**
* Try to get launch params, returns undefined if unavailable.
*/
function getLaunchParams() {
	try {
		return retrieveLaunchParams();
	} catch {
		return;
	}
}

//#endregion
//#region src/send.ts
/**
* Sends a one-way method to the host app without waiting for a response.
* Use this for fire-and-forget methods like 'app:ready'.
*
* @param method - The method name to send
* @param payload - The method payload
*
* @example
* ```ts
* import { send } from '@alien_org/bridge';
*
* send('app:ready', {});
* ```
*/
function send(method, payload) {
	sendMessage({
		type: "method",
		name: method,
		payload
	});
}

//#endregion
//#region src/utils.ts
/**
* Checks if the bridge is available.
* Utility function for checking bridge availability.
* @returns `true` if bridge is available, `false` otherwise.
*/
function isBridgeAvailable() {
	return getBridge() !== void 0;
}

//#endregion
//#region src/link-interceptor.ts
/**
* Intercepts clicks on external links and routes them through `link:open`.
*
* Same-origin links pass through for normal in-app navigation.
* Skips: modifier keys, non-left-click, download links, `javascript:`/`blob:` protocols.
*
* @returns Cleanup function to remove the interceptor.
*
* @example
* ```ts
* const disable = enableLinkInterceptor();
* // Later: disable();
* ```
*/
function enableLinkInterceptor(options = {}) {
	if (typeof window === "undefined" || !isBridgeAvailable()) return () => {};
	const { openMode } = options;
	function handler(e) {
		if (e.defaultPrevented) return;
		if (e.metaKey || e.ctrlKey || e.shiftKey || e.altKey || e.button !== 0) return;
		let el = e.target;
		while (el && el.tagName !== "A") el = el.parentElement;
		if (!el) return;
		const anchor = el;
		if (!anchor.href || anchor.hasAttribute("download")) return;
		try {
			const url = new URL(anchor.href, window.location.href);
			if (url.protocol === "javascript:" || url.protocol === "blob:") return;
			if (url.origin === window.location.origin) return;
			send("link:open", {
				url: url.href,
				openMode
			});
			e.preventDefault();
		} catch {}
	}
	document.addEventListener("click", handler);
	return () => document.removeEventListener("click", handler);
}

//#endregion
//#region src/request.ts
const DEFAULT_TIMEOUT = 3e4;
function generateReqId() {
	return typeof crypto !== "undefined" && crypto.randomUUID ? crypto.randomUUID() : Math.random().toString(36).slice(2);
}
async function request(method, params, responseEvent, options = {}) {
	const reqId = options.reqId || generateReqId();
	const timeout = options.timeout || DEFAULT_TIMEOUT;
	const payload = {
		...params,
		reqId
	};
	return new Promise((resolve, reject) => {
		const timeoutId = setTimeout(() => {
			cleanup();
			reject(new BridgeTimeoutError(String(method), timeout));
		}, timeout);
		const cleanup = () => {
			clearTimeout(timeoutId);
			off(responseEvent, handleResponse);
		};
		const handleResponse = (payload$1) => {
			if (payload$1.reqId === reqId) {
				cleanup();
				resolve(payload$1);
			}
		};
		on(responseEvent, handleResponse);
		sendMessage({
			type: "method",
			name: method,
			payload
		});
	});
}

//#endregion
exports.BridgeError = BridgeError;
exports.BridgeTimeoutError = BridgeTimeoutError;
exports.BridgeUnavailableError = BridgeUnavailableError;
exports.BridgeWindowUnavailableError = BridgeWindowUnavailableError;
exports.LaunchParamsError = LaunchParamsError;
exports.clearMockLaunchParams = clearMockLaunchParams;
exports.emit = emit;
exports.enableLinkInterceptor = enableLinkInterceptor;
exports.getLaunchParams = getLaunchParams;
exports.isBridgeAvailable = isBridgeAvailable;
exports.mockLaunchParamsForDev = mockLaunchParamsForDev;
exports.off = off;
exports.on = on;
exports.parseLaunchParams = parseLaunchParams;
exports.request = request;
exports.retrieveLaunchParams = retrieveLaunchParams;
exports.send = send;