import { BridgeError, BridgeTimeoutError, BridgeUnavailableError, BridgeWindowUnavailableError, enableLinkInterceptor, getLaunchParams, isBridgeAvailable, on, request, send, send as send$1 } from "@alien_org/bridge";
import { getMethodMinVersion, getMethodMinVersion as getMethodMinVersion$1, isMethodSupported, isMethodSupported as isMethodSupported$1 } from "@alien_org/contract";
import { createContext, useCallback, useContext, useEffect, useLayoutEffect, useMemo, useRef, useState } from "react";
import { jsx } from "react/jsx-runtime";

//#region src/context.tsx
const useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? useLayoutEffect : useEffect;
const AlienContext = createContext(null);
const SAFE_AREA_EDGES = [
	"top",
	"right",
	"bottom",
	"left"
];
function setSafeAreaCssVars(insets) {
	if (typeof document === "undefined") return;
	const root = document.documentElement;
	for (const edge of SAFE_AREA_EDGES) root.style.setProperty(`--alien-safe-area-inset-${edge}`, `${insets?.[edge] ?? 0}px`);
}
/**
* Provider component that initializes the Alien miniapp context.
* Must wrap your app to use Alien hooks.
*
* @example
* ```tsx
* import { AlienProvider } from '@alien_org/react';
*
* function App() {
*   return (
*     <AlienProvider>
*       <MyMiniapp />
*     </AlienProvider>
*   );
* }
* ```
*/
function AlienProvider({ children, autoReady = true, interceptLinks = true }) {
	const readySent = useRef(false);
	const launchParamsLoaded = useRef(false);
	const ready = useCallback(() => {
		if (readySent.current) return;
		readySent.current = true;
		if (isBridgeAvailable()) send$1("app:ready", {});
	}, []);
	const [value, setValue] = useState(() => ({
		authToken: void 0,
		contractVersion: void 0,
		isBridgeAvailable: false,
		ready
	}));
	useIsomorphicLayoutEffect$1(() => {
		const launchParams = getLaunchParams();
		const bridgeAvailable = isBridgeAvailable();
		launchParamsLoaded.current = !!launchParams;
		setValue({
			authToken: launchParams?.authToken,
			contractVersion: launchParams?.contractVersion,
			isBridgeAvailable: bridgeAvailable,
			ready
		});
		setSafeAreaCssVars(launchParams?.safeAreaInsets);
		if (!bridgeAvailable) console.warn("[@alien_org/react] Bridge is not available. Running in dev mode? The SDK will handle errors gracefully, but bridge communication will not work.");
	}, [ready]);
	useEffect(() => {
		if (autoReady && launchParamsLoaded.current) ready();
	}, [autoReady, ready]);
	useEffect(() => {
		if (interceptLinks) return enableLinkInterceptor();
	}, [interceptLinks]);
	return /* @__PURE__ */ jsx(AlienContext.Provider, {
		value,
		children
	});
}

//#endregion
//#region src/errors.ts
/**
* Base class for all React SDK errors.
*/
var ReactSDKError = class extends Error {
	constructor(message) {
		super(message);
		this.name = "ReactSDKError";
	}
};
/**
* Error thrown when a method is not supported by the current contract version.
*/
var MethodNotSupportedError = class extends ReactSDKError {
	method;
	contractVersion;
	minVersion;
	constructor(method, contractVersion, minVersion) {
		const message = minVersion ? `Method "${method}" requires version ${minVersion}, but host provides ${contractVersion ?? "unknown"}` : `Method "${method}" is not supported`;
		super(message);
		this.name = "MethodNotSupportedError";
		this.method = method;
		this.contractVersion = contractVersion;
		this.minVersion = minVersion;
	}
};

//#endregion
//#region src/hooks/useAlien.ts
/**
* Hook to access the Alien context.
* Must be used within an AlienProvider.
*
* For additional launch params (platform, startParam, hostAppVersion),
* use the `useLaunchParams` hook.
*
* @example
* ```tsx
* const { authToken, contractVersion, isBridgeAvailable } = useAlien();
* ```
*/
function useAlien() {
	const context = useContext(AlienContext);
	if (!context) throw new Error("useAlien must be used within an AlienProvider");
	return context;
}

//#endregion
//#region src/hooks/useClipboard.ts
/**
* Hook for clipboard operations.
*
* @example
* ```tsx
* function ClipboardDemo() {
*   const { writeText, readText, isReading, errorCode, supported } = useClipboard();
*
*   if (!supported) return null;
*
*   return (
*     <>
*       <button onClick={() => writeText('Hello!')}>Copy</button>
*       <button
*         onClick={async () => {
*           const text = await readText();
*           if (text !== null) console.log('Pasted:', text);
*         }}
*         disabled={isReading}
*       >
*         Paste
*       </button>
*       {errorCode && <span>Error: {errorCode}</span>}
*     </>
*   );
* }
* ```
*/
function useClipboard(options = {}) {
	const { timeout = 5e3 } = options;
	const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
	const [isReading, setIsReading] = useState(false);
	const [errorCode, setErrorCode] = useState(null);
	const supported = contractVersion ? isMethodSupported$1("clipboard:write", contractVersion) && isMethodSupported$1("clipboard:read", contractVersion) : true;
	const writeText = useCallback((text) => {
		if (!isBridgeAvailable$1) return;
		if (contractVersion && !isMethodSupported$1("clipboard:write", contractVersion)) return;
		send$1("clipboard:write", { text });
	}, [isBridgeAvailable$1, contractVersion]);
	const readText = useCallback(async () => {
		if (!isBridgeAvailable$1) return null;
		if (contractVersion && !isMethodSupported$1("clipboard:read", contractVersion)) return null;
		setIsReading(true);
		setErrorCode(null);
		try {
			const response = await request("clipboard:read", {}, "clipboard:response", { timeout });
			if (response.errorCode) {
				setErrorCode(response.errorCode);
				return null;
			}
			return response.text;
		} catch {
			return null;
		} finally {
			setIsReading(false);
		}
	}, [
		isBridgeAvailable$1,
		contractVersion,
		timeout
	]);
	return useMemo(() => ({
		writeText,
		readText,
		isReading,
		errorCode,
		supported
	}), [
		writeText,
		readText,
		isReading,
		errorCode,
		supported
	]);
}

//#endregion
//#region src/hooks/useEvent.ts
/**
* Hook to subscribe to bridge events.
* Automatically handles subscription cleanup on unmount.
*
* @param event - The event name to subscribe to.
* @param callback - The callback to invoke when the event is received.
*
* @example
* ```tsx
* import { useEvent } from '@alien_org/react';
*
* function MyComponent() {
*   useEvent('miniapp:close', () => {
*     // Cleanup before miniapp closes
*     saveState();
*   });
*
*   useEvent('host.back.button:clicked', () => {
*     // Handle back button press
*     navigateBack();
*   });
*
*   return <div>Listening for events...</div>;
* }
* ```
*/
function useEvent(event, callback) {
	const callbackRef = useRef(callback);
	callbackRef.current = callback;
	const { isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
	useEffect(() => {
		if (!isBridgeAvailable$1) {
			console.warn("[@alien_org/react] Bridge is not available. Event listener will not be set up. Running in dev mode?");
			return;
		}
		const handler = (payload) => {
			callbackRef.current(payload);
		};
		try {
			return on(event, handler);
		} catch (error) {
			console.warn("[@alien_org/react] Failed to set up event listener:", error instanceof Error ? error.message : String(error));
			return;
		}
	}, [event, isBridgeAvailable$1]);
}

//#endregion
//#region src/hooks/useIsMethodSupported.ts
/**
* Hook to check if a method is supported by the host app's contract version.
*
* @param method - The method name to check.
* @returns Object with `supported`, `contractVersion`, and `minVersion`.
*
* @example
* ```tsx
* import { useMethodSupported } from '@alien_org/react';
*
* function MyComponent() {
*   const { supported, minVersion } = useMethodSupported('payment:request');
*
*   if (!supported) {
*     return <div>This feature requires version {minVersion}</div>;
*   }
*
*   return <div>Feature available!</div>;
* }
* ```
*/
function useIsMethodSupported(method) {
	const { contractVersion } = useAlien();
	return {
		supported: contractVersion ? isMethodSupported$1(method, contractVersion) : true,
		contractVersion,
		minVersion: getMethodMinVersion$1(method)
	};
}

//#endregion
//#region src/hooks/useLaunchParams.ts
const useIsomorphicLayoutEffect = typeof window !== "undefined" ? useLayoutEffect : useEffect;
/**
* Hook to get launch params.
* Returns undefined if params unavailable (use mockLaunchParamsForDev in dev).
*
* @example
* ```tsx
* import { useLaunchParams } from '@alien_org/react';
*
* function MyComponent() {
*   const launchParams = useLaunchParams();
*
*   if (!launchParams) {
*     return <div>Running outside Alien App</div>;
*   }
*
*   return <div>Platform: {launchParams.platform}</div>;
* }
* ```
*/
function useLaunchParams() {
	const [params, setParams] = useState(void 0);
	useIsomorphicLayoutEffect(() => {
		setParams(getLaunchParams());
	}, []);
	return params;
}

//#endregion
//#region src/hooks/useLinkInterceptor.ts
/**
* Intercepts external link clicks and routes them through the bridge.
* Activates when the bridge is available, cleans up on unmount.
*
* @example
* ```tsx
* function App() {
*   useLinkInterceptor();
*   return <a href="https://external.com">Opens via host app</a>;
* }
* ```
*/
function useLinkInterceptor(options = {}) {
	const { isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
	const { openMode } = options;
	useEffect(() => {
		if (!isBridgeAvailable$1) return;
		return enableLinkInterceptor({ openMode });
	}, [isBridgeAvailable$1, openMode]);
}

//#endregion
//#region src/hooks/useMethod.ts
/**
* Hook for making bridge requests with loading/error state management.
*
* @param method - The method name to call.
* @param responseEvent - The event name to listen for the response.
* @param options - Hook options including version checking.
* @returns Object with `execute`, `reset`, `data`, `error`, `isLoading`, and `supported`.
*
* @example
* ```tsx
* import { useMethod } from '@alien_org/react';
*
* function PayButton() {
*   const { execute, data, error, isLoading, supported } = useMethod(
*     'payment:request',
*     'payment:response',
*   );
*
*   if (!supported) {
*     return <div>This feature is not available</div>;
*   }
*
*   const handlePay = async () => {
*     // Errors are automatically set in the `error` state - no try/catch needed!
*     const { error, data } = await execute({
*       recipient: 'wallet-123',
*       amount: '100',
*       token: 'SOL',
*       network: 'solana',
*       invoice: 'inv-123',
*     });
*     if (error) {
*         console.error(error);
*         return;
*     }
*     if (data) {
*       console.log('Success:', data);
*     }
*   };
*
*   if (isLoading) return <button disabled>Loading...</button>;
*   if (error) return <div>Error: {error.message}</div>;
*   if (data) return <div>Payment complete!</div>;
*
*   return <button onClick={handlePay}>Pay</button>;
* }
* ```
*/
function useMethod(method, responseEvent, options = {}) {
	const { checkVersion = true } = options;
	const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
	const [state, setState] = useState({
		data: void 0,
		error: void 0,
		isLoading: false
	});
	const supported = contractVersion ? isMethodSupported$1(method, contractVersion) : true;
	const execute = useCallback(async (params, requestOptions) => {
		if (!isBridgeAvailable$1) {
			const error = /* @__PURE__ */ new Error("Bridge is not available. Running in dev mode? Bridge communication will not work.");
			console.warn("[@alien_org/react]", error.message);
			setState({
				data: void 0,
				error,
				isLoading: false
			});
			return {
				data: void 0,
				error
			};
		}
		if (checkVersion) {
			if (contractVersion && !isMethodSupported$1(method, contractVersion)) {
				const error = new MethodNotSupportedError(method, contractVersion, getMethodMinVersion$1(method));
				setState({
					data: void 0,
					error,
					isLoading: false
				});
				return {
					data: void 0,
					error
				};
			}
		}
		setState({
			data: void 0,
			error: void 0,
			isLoading: true
		});
		try {
			const response = await request(method, params, responseEvent, requestOptions);
			setState({
				data: response,
				error: void 0,
				isLoading: false
			});
			return {
				data: response,
				error: void 0
			};
		} catch (err) {
			if (err instanceof BridgeError) {
				console.warn("[@alien_org/react] Bridge error:", err.message);
				setState({
					data: void 0,
					error: err,
					isLoading: false
				});
				return {
					data: void 0,
					error: err
				};
			}
			const error = err instanceof Error ? err : new Error(String(err));
			setState({
				data: void 0,
				error,
				isLoading: false
			});
			return {
				data: void 0,
				error
			};
		}
	}, [
		method,
		responseEvent,
		checkVersion,
		contractVersion,
		isBridgeAvailable$1
	]);
	const reset = useCallback(() => {
		setState({
			data: void 0,
			error: void 0,
			isLoading: false
		});
	}, []);
	return useMemo(() => ({
		...state,
		execute,
		reset,
		supported
	}), [
		state,
		execute,
		reset,
		supported
	]);
}

//#endregion
//#region src/hooks/usePayment.ts
/**
* Hook for handling payments with full state management.
*
* Provides an easy-to-use interface for initiating payments and reacting
* to status changes. Automatically handles loading states, errors, and
* version checking.
*
* @param options - Optional configuration and callbacks.
* @returns Payment state and methods.
*
* @example
* ```tsx
* import { usePayment } from '@alien_org/react';
*
* function BuyButton({ orderId }: { orderId: string }) {
*   const {
*     pay,
*     isLoading,
*     isPaid,
*     txHash,
*     error,
*   } = usePayment({
*     onPaid: (txHash) => console.log('Paid!', txHash),
*     onCancelled: () => console.log('Cancelled'),
*     onFailed: (code) => console.log('Failed:', code),
*   });
*
*   const handleBuy = () => pay({
*     recipient: 'wallet-address',
*     amount: '1000000',
*     token: 'SOL',
*     network: 'solana',
*     invoice: orderId,
*     title: 'Premium Plan',
*   });
*
*   if (isPaid) return <div>Thank you! TX: {txHash}</div>;
*
*   return (
*     <button onClick={handleBuy} disabled={isLoading}>
*       {isLoading ? 'Processing...' : 'Buy Now'}
*     </button>
*   );
* }
* ```
*/
function usePayment(options = {}) {
	const { timeout = 12e4, onPaid, onCancelled, onFailed, onStatusChange } = options;
	const { contractVersion, isBridgeAvailable: isBridgeAvailable$1 } = useAlien();
	const callbacksRef = useRef({
		onPaid,
		onCancelled,
		onFailed,
		onStatusChange
	});
	callbacksRef.current = {
		onPaid,
		onCancelled,
		onFailed,
		onStatusChange
	};
	const [state, setState] = useState({ status: "idle" });
	const supported = contractVersion ? isMethodSupported$1("payment:request", contractVersion) : true;
	const updateState = useCallback((newState) => {
		setState(newState);
		callbacksRef.current.onStatusChange?.(newState.status);
	}, []);
	const pay = useCallback(async (params) => {
		if (!isBridgeAvailable$1) {
			const error = /* @__PURE__ */ new Error("Bridge is not available. Running in dev mode?");
			console.warn("[@alien_org/react]", error.message);
			const result = {
				status: "failed",
				errorCode: "unknown",
				error
			};
			updateState(result);
			callbacksRef.current.onFailed?.("unknown", error);
			return result;
		}
		if (contractVersion && !isMethodSupported$1("payment:request", contractVersion)) {
			const error = new MethodNotSupportedError("payment:request", contractVersion, getMethodMinVersion$1("payment:request"));
			const result = {
				status: "failed",
				errorCode: "unknown",
				error
			};
			updateState(result);
			callbacksRef.current.onFailed?.("unknown", error);
			return result;
		}
		updateState({ status: "loading" });
		try {
			const response = await request("payment:request", params, "payment:response", { timeout });
			if (response.status === "paid") {
				const txHash = response.txHash ?? "";
				const result$1 = {
					status: "paid",
					txHash
				};
				updateState(result$1);
				callbacksRef.current.onPaid?.(txHash);
				return result$1;
			}
			if (response.status === "cancelled") {
				const result$1 = { status: "cancelled" };
				updateState(result$1);
				callbacksRef.current.onCancelled?.();
				return result$1;
			}
			const errorCode = response.errorCode ?? "unknown";
			const result = {
				status: "failed",
				errorCode
			};
			updateState(result);
			callbacksRef.current.onFailed?.(errorCode);
			return result;
		} catch (err) {
			const error = err instanceof Error ? err : new Error(String(err));
			if (err instanceof BridgeError) console.warn("[@alien_org/react] Bridge error:", err.message);
			const result = {
				status: "failed",
				errorCode: "unknown",
				error
			};
			updateState(result);
			callbacksRef.current.onFailed?.("unknown", error);
			return result;
		}
	}, [
		isBridgeAvailable$1,
		contractVersion,
		timeout,
		updateState
	]);
	const reset = useCallback(() => {
		updateState({ status: "idle" });
	}, [updateState]);
	return useMemo(() => ({
		status: state.status,
		isLoading: state.status === "loading",
		isPaid: state.status === "paid",
		isCancelled: state.status === "cancelled",
		isFailed: state.status === "failed",
		txHash: state.txHash,
		errorCode: state.errorCode,
		error: state.error,
		pay,
		reset,
		supported
	}), [
		state,
		pay,
		reset,
		supported
	]);
}

//#endregion
export { AlienProvider, BridgeError, BridgeTimeoutError, BridgeUnavailableError, BridgeWindowUnavailableError, MethodNotSupportedError, ReactSDKError, getMethodMinVersion, isMethodSupported, send, useAlien, useClipboard, useEvent, useIsMethodSupported, useLaunchParams, useLinkInterceptor, useMethod, usePayment };